<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>What Affects Learning Gains?</title>
		<style>

		.A.dot{
			fill: #FFA500;
		}
		
		.B.dot{
			fill: #4169E1;
		}
		
		.unknown.dot{
			opacity: 0.0;
		}
		
		.bar{
			stroke-width: 2;
		}
        
        .hitArea{
            fill:none;
            pointer-events: all;
        }

        .hitArea:hover + rect{
            stroke: black;
        }
        
		rect.bar:hover{
			stroke: black;
		}

		.A.correct{
			fill: #FFA500;
			stroke: #FFA500;
		}
		
		.B.correct{
			fill: #4169E1;
			stroke: #4169E1;
		}
		
		.A.incorrect{
			fill: #DFCBA6;
			stroke: #DFCBA6;
		}
		
		.B.incorrect{
			fill: #D5D8E4;
			stroke: #D5D8E4;
		}
				
		.switch.unpressed{
			fill: #D3D3D3;
			stroke: #D3D3D3;
			stroke-width: 2;
		}
		
		.switch.pressed{
			fill: #A8A8A8;
			stroke: #494949;
			stroke-width: 2;
		}

		
		.switch.unpressed:hover{
			fill: #808080;
			stroke: #808080;
		}
		
		.buttonText{
			pointer-events:none;
			font-size: 10pt;
            font-family: Verdana;
		}
		
		.buttonHolder{
			fill: #000000:
		}
		.axis {
            font-size: 10pt;
            font-family: Verdana;
            color: #CCCCCC;
            fill-opacity: .6;			
        }

		.axis path,
		.axis line {
			stroke: #CCCCCC;
			fill: none;
			stroke-width: 1px;
		}
		
		.axis path.domain{
			stroke-width: 0px;
		}
		
		.zero.axis{
			stroke-dasharray: 1,2;
			stroke-width: 1px;
			stroke: #808080;
		}
		.tick {
			font-size: 8pt;
		}
		
		svg{
		}
		</style>
		<script src="d3.min.js"></script>
	</head>
<body>
<script>
/******************************************
 * Layout and appearance variables 
 ******************************************/
var graphHeight = 200, 
	graphWidth = 200;
var problemSelectorHeight = 100;
var margin = {top: 50, right: 50, bottom: 50, left: 50};
var width = (10*graphWidth) + (8*margin.left), 
	height = (2*graphHeight) + (3*margin.top) + 2*problemSelectorHeight;

var defaultRange = [0, graphWidth]; //for visual mapping, so should be same for all graphs?

var barWidth = 10;
var barSpacing = (barWidth*2) + 20;
var barMargin = {top: 10, right: 10, bottom: 10, left: 10};
var barStrokeWidth = 2;
var barHitVert = 10; //extra hit area padding for top or bottom
var barHitHor = 10; //extra hit area padding for left or right

var buttonHeight = 20, 
	buttonWidth = 100;
	
/******************************************
 * Global(?) functions/variables - maybe put into their individual callbacks to prevent accidentally overwriting axes/scale info
 ******************************************/
 	//Holds data from CSV files
 	var conditions = [];
	var graphParams = [];
    var studentDataset = [];
    var problemsDataset = [];
    
    //Default starting variables
    var CURRENT_UNIT = "2";
    var CURRENT_PREPOST= "Pre"; 
    var CURRENT_BUTTON = null;
    
    //the main SVG
    var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)

	//y axis - should be the same for all graphs
	function addYAxis(elem, offset){
		elem.append("g")
		  .attr("class", "y axis")
		  .call(yAxis)
		.append("text")
		  .attr("transform", "rotate(-90)")
		  .attr("y", 0 - margin.left)
		  .attr("x",0 - (graphHeight / 2))
		  .attr("dy", "1.5em")
		  .style("text-anchor", "middle")
		  .text("Learning Gains");
    }
    
	var yScale = d3.scale.linear()
		.domain([-20, 20]) //default, is changed in callback
		.range([200, 0]);

	var yAxis = d3.svg.axis()
		.scale(yScale)
		.orient("left")
		.ticks(10, "")


/******************************
 * Map student data to graphs
 ******************************/	
function drawDots(){
	//Alter the range for Y axis
	var min = d3.min(studentDataset, function(d) { return +d["Unit " + CURRENT_UNIT + " Learning Gain"];})
	var max = d3.max(studentDataset, function(d) { return +d["Unit " + CURRENT_UNIT + " Learning Gain"];})
	var yDottedOffset = Math.abs(max - min) * 0.1;
	yScale.domain([min-yDottedOffset, max]); //TODO make min like 10% less than actual min or something
	
	console.log("finished scaling");
	d3.selectAll(graphParams)
		.each(function(d, i) {
			//Current Graph Holder
			var holder = svg.select(".graph" + i + ".graphHolder");
			holder.selectAll(".axis").remove();
			
			//X Scale and Axis
			//TODO nonstatic offset for domain, based on actual data domain, maybe 10%?
			min = d3.min(studentDataset, function(d) { return +d[graphParams[i]];})
			max = d3.max(studentDataset, function(d) { return +d[graphParams[i]];})
		    var xDottedOffset = Math.abs(max - min) * 0.1;
			
			var x = d3.scale.linear()
					.domain([min-xDottedOffset, max])
					.range(defaultRange);
							
			//X Axis
			var xAxis = d3.svg.axis()
					.scale(x)
					.orient("bottom")
					.ticks(5, "");
			
			holder.append("g")
					.attr("class", "x axis")
					.attr("transform", "translate(0," + graphHeight + ")")
					.call(xAxis)
				  .append("text")
					  .attr("transform", "translate(" + (graphWidth / 2) + " ," + (margin.bottom-15) + ")")
					  .style("text-anchor", "middle")
					  .text(graphParams[i]);
			
			//Y Axis
			addYAxis(holder, yDottedOffset);
					
			//Dotted lines intersecting at 0
			//Vertical Line
			holder.append("line")
					.attr("class", graphParams[i] + " zero axis")
					.attr("x1", x(0))
					.attr("y1", 0)
					.attr("x2", x(0))
					.attr("y2", graphHeight)
			
			//Horizontal Line
			holder.append("line")
					.attr("class", graphParams[i] + " zero axis")
					.attr("x1", 0)
					.attr("y1", yScale(0))
					.attr("x2", graphWidth)
					.attr("y2", yScale(0));
										
			//Redraw/Draw dots					
			var dots = holder.selectAll("circle")
				.data(studentDataset);
													
			dots.enter().append("circle")
				.attr("cy", 0)
				.attr("cx", 0)
				.attr("r", 1.5);
			
			dots.attr("class", function(d) {
						var t = d["Unit " + CURRENT_UNIT + " Pre-Test Type"].toUpperCase();
						if(CURRENT_PREPOST == "Post"){
							if(t == "A")
								t == "B";
							else if(t == "B")
								t == "A";
							else
								t == "unknown";
						}
						if(t == "A" || t == "B")
							return t + " dot";
						else
							return "unknown dot";
					})
				.attr("transform", function(d) { 
							var gains = d["Unit " + CURRENT_UNIT + " Learning Gain"];
							var cat = +d[graphParams[i]];
			
							if(isNaN(gains) || isNaN(cat))
								return "translate(0,0)";
							else
								return "translate(" + x(cat) + "," + yScale(+gains) + ")";
						})
				.attr("opacity", function(d){ return isNaN(d["Unit " + CURRENT_UNIT + " Learning Gain"]) ? 0 : 1;})
			
			dots.exit()
				.remove();
	});
}

// version that does not nest by condition
function drawGraphs() {
	d3.csv("students2.csv", function(data){
		
		//Assign loaded data to variables
		studentDataset = data.map(function(d){return d;});
		graphParams = d3.keys(data[0]).slice(14, 20); //only select the 6 parameters we want to make graphs for

		d3.selectAll(graphParams)
			.each(function(d, i) {		
				// Create the graph container
				var colNum = i;
				var rowNum = 0;
				if (i > 2) {
					colNum = i - 3;
					rowNum = 1;
				}
				console.log("colNum: " + colNum + " rowNum: " + rowNum)
				var holderX = margin.left + colNum*(graphWidth+2*margin.left);
				var holderY = margin.top - 30 + rowNum*(graphHeight+margin.top+20);
				console.log("holderX: " + holderX + " holderY: " + holderY);
				var holder = svg.append("g")
					.attr("class", " graph" + i + " graphHolder")
					.attr("width", graphWidth)
					.attr("height", graphHeight)
					.attr("transform", "translate(" + holderX + "," + holderY + ")");
			});
		
		drawDots();
	});
}

//initial loading
drawGraphs();

/********************************
Map problem correctness data to bottom bar
********************************/
	//Container
	var barsholderX = margin.left;
	var barsholderY = (2*graphHeight) + (3*margin.top);
	var barsholder = svg.append("g")
		.attr("class", "barsHolder")
		.attr("width", width)
		.attr("height", problemSelectorHeight)
		.attr("transform", "translate(" + barsholderX + "," + barsholderY + ")");
		
    //TODO alter the range based on actual learning gains range?
	var barsY = d3.scale.linear()
		.domain([0, 1])
		.range([100+barStrokeWidth, 0]); 

	var barsYAxis = d3.svg.axis()
		.scale(barsY)
		.orient("left")
		.ticks(2, "%");	
		
	//Y Axis, percentage
	barsholder.append("g")
		  .attr("class", "axis")
		  .call(barsYAxis)
		.append("text")
		  .attr("transform", "rotate(-90)")
		  .attr("y", 0 - margin.left)
		  .attr("x",0 - (problemSelectorHeight / 2))
		  .attr("dy", "0.8em")
		  .style("text-anchor", "middle")
		  .text("% Correct");
		  
	//TODO clean this part up a bit? forloop + array for class names, maybe
	//Holders for correct bars
	barsholder.append("g")
	   .attr("class", "correctBarsA oneBarTypeHolder")
	   .attr("width", width)
	   .attr("height", problemSelectorHeight)
	
	barsholder.append("g")
	   .attr("class", "correctBarsB oneBarTypeHolder")
	   .attr("width", width)
	   .attr("height", problemSelectorHeight)
	   
	//Holders for incorrect bars
	barsholder.append("g")
	   .attr("class", "incorrectBarsA oneBarTypeHolder")
	   .attr("width", width)
	   .attr("height", problemSelectorHeight)
	
	barsholder.append("g")
	   .attr("class", "incorrectBarsB oneBarTypeHolder")
	   .attr("width", width)
	   .attr("height", problemSelectorHeight)
	   
//TODO separate out drawing the gridlines and the bars like I did for the dots
function drawProblemBars(){    
d3.csv("problems2.csv", function(data){
	problemsDataset = data.map(function(d){return d;});

	//TODO create a wrapper for each bar that is its mouseover area
	//.data([{selected: false}]) to store info about whether it is pressed or not
	//add interactivity to bars 

	//Nest by Unit
	var groups = d3.nest()
		 .key(function(d) { return d.Unit; })
		 .key(function(d) { return d.Type; })
		 .entries(data);

	//Select all rows of current unit
	d3.selectAll(groups)
		.each(function(d2, k){ 
			if(this.key == CURRENT_UNIT){
				//Map A and B separately for 4 groups of bars: A-correct, A-incorrect, B-correct, B-incorrect 
				d3.selectAll(this.values)
					.each(function(dat, j) {

                       	//TODO bars with 0 values look really weird
                        //simplify selection for pre/post
                        var corr = CURRENT_PREPOST + " Correct";
                        var incorr = CURRENT_PREPOST + " Incorrect";

                        var correctBars = barsholder.select(".correctBars" + this.key)
                                .selectAll("g")
                                .data(this.values);
                        correctBars.enter().append("g");
                       
                        //must draw hitArea before actual bar for CSS next sibling selector to work            
  						correctBars
							.append("rect")
                            .data(this.values)
									  .attr("class", " hitArea")
                                      .attr("x", function(d, i) { return (-1*barHitHor + j*barHitHor) + (j*(barStrokeWidth + barWidth))+i*(barSpacing); })
                                      .attr("y", function(d){ return barsY(+d[corr]/(+d[corr]+(+d[incorr])));})
									  .attr("width", barWidth + barHitHor)
									  .attr("height", function(d) {return barHitVert + barStrokeWidth + problemSelectorHeight - barsY(+d[corr]/(+d[corr]+(+d[incorr]))); });                                     
						correctBars
							.append("rect")
                            .data(this.values)
									  .attr("class", this.key + " correct bar")
									  .attr("x", function(d, i) { return (j*(barStrokeWidth + barWidth))+i*(barSpacing); })
									  .attr("width", barWidth)
									  .attr("y", function(d){ return barsY(+d[corr]/(+d[corr]+(+d[incorr])));})
									  .attr("height", function(d) {return barStrokeWidth + problemSelectorHeight - barsY(+d[corr]/(+d[corr]+(+d[incorr]))); });	
    
						correctBars.exit().remove();

                        var incorrectBars = barsholder.select(".incorrectBars" + this.key)
                                .selectAll("g")
                                .data(this.values);
                        incorrectBars.enter().append("g");

                        //must draw hitArea before actual bar for CSS next sibling selector to work            
  						incorrectBars
							.append("rect")
                            .data(this.values)
                              .attr("class", " hitArea")
                              .attr("x", function(d, i) { return (-1*barHitHor + j*barHitHor) + (j*(barStrokeWidth + barWidth))+i*(barSpacing); })
                              .attr("y", -1*barHitVert)
                              .attr("width", barWidth + barHitHor)
                              .attr("height", function(d) {return barHitVert + Math.max(0, problemSelectorHeight - barsY(+d[incorr]/(+d[corr]+(+d[incorr])))); });                                     
						incorrectBars
							.append("rect")
                            .data(this.values)
								.attr("class", this.key + " incorrect bar")
								.attr("x", function(d, i) { return (j*(barStrokeWidth + barWidth))+i*(barSpacing); })
                                .attr("width", barWidth)
								.attr("y", 0)
								.attr("height", function(d) { return Math.max(0, problemSelectorHeight - barsY(+d[incorr]/(+d[corr]+(+d[incorr])))); });                      
                               
						incorrectBars.exit().remove();		
					});
				}					
			});		
		});
}
drawProblemBars();

		
/******************************
Buttons
******************************/	
var buttons = [];
var buttonNames = ["Unit 2 Pre", "Unit 2 Post", "Unit 4 Pre", "Unit 4 Post"];
var shrinkConstant = 0.98;

//Change size of an unpressed button
function setUnpressedSize(){
	this.attr("class", "switch unpressed");
}

//Change size of a pressed button
function setPressedSize(){
	this.attr("class", "switch pressed");	
}
//Function that switches Unit Pre Post
function switchCondition(e){
	var pr = CURRENT_PREPOST;
	var un = CURRENT_UNIT
	
	switch(e.name){
		case buttonNames[0]:
			CURRENT_PREPOST = "Pre"
			CURRENT_UNIT = "2";
		break;
		case buttonNames[1]:
			CURRENT_PREPOST = "Post"
			CURRENT_UNIT = "2";
		break;
		case buttonNames[2]:
			CURRENT_PREPOST = "Pre"
			CURRENT_UNIT = "4";
		break;
		case buttonNames[3]:
			CURRENT_PREPOST = "Post"
			CURRENT_UNIT = "4";
		break;
	}
	if(CURRENT_PREPOST != pr || CURRENT_UNIT != un){
		for(var x = 0; x < buttonNames.length; x++){
			if (buttonNames[x] != e.name){
				buttons[buttonNames[x]].select("rect").call(setUnpressedSize);
			}
			else{
				buttons[buttonNames[x]].select("rect").call(setPressedSize);
			}
		}
		drawDots();
		drawProblemBars();
	}
}
//Make buttons to switch between Unit, Pre-Post (4 conditions total)
for(var x = 0; x < buttonNames.length; x++){

		var dy = x <= 1 ? 0 : 1;
		var temp  = svg.append("g")
		.attr("class", "buttonHolder")
		.attr("transform", "translate(" + (900+110*(x%2)) + "," + 1.5*buttonHeight*dy + ")");

		var n = buttonNames[x];
		temp.append("rect")
			.data([{name: n}])
			.attr("class", "switch unpressed")
			.attr("width", buttonWidth)
			.attr("height", buttonHeight)
			.on("click", function(e){switchCondition(e);});
		
		temp.append("text")
			.attr("class", "buttonText")
			.attr("transform", "translate(" + buttonWidth/5 + "," + buttonHeight/1.5 + ")")
			.text(buttonNames[x]);

		buttons[n] = temp;
}

buttons[buttonNames[0]].select("rect").attr("class", "switch pressed");

</script>
</body>
</html>
