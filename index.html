<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>What Affects Learning Gains?</title>
		<style>

		.A.dot{
			fill: #FFA500;
		}
		
		.B.dot{
			fill: #4169E1;
		}
		
		.unknown.dot{
			fill: #000000;
		}
		
		.A.correctbar{
			fill: #FFA500;
		}
		
		.B.correctbar{
			fill: #4169E1;
		}
		
		.A.incorrectbar{
			fill: #DFCBA6;
		}
		
		.B.incorrectbar{
			fill: #D5D8E4;
		}
		
		.switch{
			fill: lightgrey;
		}
		
		.switch:hover{
			fill: grey;
		}
		
		.buttonText{
			pointer-events:none;
		}
		svg{
		}
		</style>
		<script src="d3.min.js"></script>
	</head>
<body>
<script>
/******************************************
Layout and appearance variables 
 ******************************************/
var graphHeight = 200, 
	graphWidth = 200;
var problemSelectorHeight = 100;
var margin = {top: 50, right: 50, bottom: 50, left: 50};
var width = (7*graphWidth) + (8*margin.left), 
	height = (2*graphHeight) + (3*margin.top) + 2*problemSelectorHeight;

var defaultRange = [0, graphWidth]; //for visual mapping, so should be same for all graphs?

var barWidth = 15;
var barMargin = {top: 10, right: 10, bottom: 10, left: 10};

var buttonHeight = 20, 
	buttonWidth = 100;
/******************************************
Global(?) functions/variables - maybe put into their individual callbacks to prevent accidentally overwriting axes/scale info
 ******************************************/
 	//Holds data from CSV files
 	var conditions = [];
	var graphParams = [];
    var studentDataset = [];
    var problemsDataset = [];
    
    //Default starting variables
    var CURRENT_UNIT = "2";
    var CURRENT_PREPOST= "Pre"; 
    
    //the main SVG
    var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)

	//y axis - should be the same for all graphs
	function addYAxis(elem){
		elem.append("g")
		  .attr("class", "y axis")
		  .call(yAxis)
		.append("text")
		  .attr("transform", "rotate(-90)")
		  .attr("y", 6)
		  .attr("dy", ".71em")
		  .style("text-anchor", "end")
		  .text("Learning Gains");
    }
    
	var yScale = d3.scale.linear()
		.domain([-20, 20]) //default, is changed in callback
		.range([200, 0]);

	var yAxis = d3.svg.axis()
		.scale(yScale)
		.orient("left")
		.ticks(10, "");
/******************************
Map student data to graphs
******************************/	
function drawDots(){
console.log("here");
	d3.selectAll(conditions)
		.each(function(d2, j){ 
		d3.selectAll(graphParams)
			.each(function(d, i) {
			//X Scale
			var x = d3.scale.linear()
					.domain([0, d3.max(studentDataset, function(d) { return +d[graphParams[i]];} )])
					.range(defaultRange);
								
			var dots = svg.select(".graph" + i + ".type" + j + ".graphHolder").selectAll("circle")
				.data(conditions[j].values);
														
			dots.enter().append("circle")
				.attr("cy", 0)
				.attr("cx", 0)
				.attr("r", 2);
				
			dots.attr("class", function(d) {
						var t = d["Unit " + CURRENT_UNIT + " Pre-Test Type"].toUpperCase();
						if(CURRENT_PREPOST == "Post"){
							if(t == "A")
								t == "B";
							else if(t == "B")
								t == "A";
						}
						if(t == "A" || t == "B")
						return t + " dot";
						else
						return "unknown dot";
					})
				.attr("transform", function(d) { 
							var gains = d["Unit 2 Learning Gain"];
							var cat = +d[graphParams[i]];
				
							if(isNaN(gains) || isNaN(cat))
								return "translate(0,0)";
							else
								return "translate(" + x(cat) + "," + yScale(+gains) + ")";
						})
				.attr("opacity", function(d){ return (d["Unit " + CURRENT_UNIT + " Learning Gain"] == "null") ? 0 : 1;})

			dots.exit()
				.remove();
		});
	});
}
//Call this once at beginning to set up axes and groups
function drawGraphs(){
		d3.csv("students2.csv", function(data){

				//Assign loaded data to variables
				studentDataset = data.map(function(d){return d;});
				graphParams = d3.keys(data[0]).slice(14, 20); //only select the 6 parameters we want to make graphs for
			
				//Nest by condition (tablet, paper)
				conditions = d3.nest()
					 .key(function(d) { return d.Condition; })
					 .entries(data);

				//alter the range for Y axis
				yScale.domain(d3.extent(studentDataset, function(d) { return +d["Unit " + CURRENT_UNIT + " Learning Gain"];}));
			
				//Create a separate scale+axis for each parameter we care about
				d3.selectAll(conditions)
					.each(function(d2, j){ 
						d3.selectAll(graphParams)
						.each(function(d, i) {
					
						//Container
						var holderX = margin.left+i*(graphWidth+2*margin.left);
						var holderY = j*(graphHeight+margin.top)+margin.top;
						var holder = svg.append("g")
							.attr("class", " graph" + i + " type" + j + " graphHolder")
							.attr("width", graphWidth)
							.attr("height", graphHeight)
							.attr("transform", "translate(" + holderX + "," + holderY + ")");
						//X Scale
						var x = d3.scale.linear()
								.domain([0, d3.max(studentDataset, function(d) { return +d[graphParams[i]];} )])
								.range(defaultRange);
										
						//X Axis
						var xAxis = d3.svg.axis()
								.scale(x)
								.orient("bottom");
			
						holder.append("g")
								.attr("class", graphParams[i] + " x axis")
								.attr("transform", "translate(0," + graphHeight + ")")
								.call(xAxis)
							  .append("text")
								  .style("text-anchor", "start")
								  .text(graphParams[i]);
						//Y Axis
						addYAxis(holder);
					});
			});	
		drawDots();
	});

}

//initial loading
drawGraphs();
/********************************
Map problem correctness data to bottom bar
********************************/
	//Container
	var barsholderX = margin.left;
	var barsholderY = (2*graphHeight) + (3*margin.top);
	var barsholder = svg.append("g")
		.attr("class", "barsHolder")
		.attr("width", width)
		.attr("height", problemSelectorHeight)
		.attr("transform", "translate(" + barsholderX + "," + barsholderY + ")");
		
    //TODO alter the range based on actual learning gains range?
	var barsY = d3.scale.linear()
		.domain([0, 1])
		.range([100, 0]); 

	var barsYAxis = d3.svg.axis()
		.scale(barsY)
		.orient("left")
		.ticks(2, "%");	
		
	//Y Axis, percentage
	barsholder.append("g")
		  .attr("class", "barsYAxis")
		  .call(barsYAxis)
		.append("text")
		  .attr("transform", "rotate(-90)")
		  .attr("y", 6)
		  .attr("dy", ".71em")
		  .style("text-anchor", "end")
		  .text("%");
		  
	//TODO clean this part up a bit? forloop + array for class names, maybe
	//Holders for correct bars
	barsholder.append("g")
	   .attr("class", "correctBarsA oneBarTypeHolder")
	   .attr("width", width)
	   .attr("height", problemSelectorHeight)
	
	barsholder.append("g")
	   .attr("class", "correctBarsB oneBarTypeHolder")
	   .attr("width", width)
	   .attr("height", problemSelectorHeight)
	   
	//Holders for incorrect bars
	barsholder.append("g")
	   .attr("class", "incorrectBarsA oneBarTypeHolder")
	   .attr("width", width)
	   .attr("height", problemSelectorHeight)
	
	barsholder.append("g")
	   .attr("class", "incorrectBarsB oneBarTypeHolder")
	   .attr("width", width)
	   .attr("height", problemSelectorHeight)
	   
//TODO separate out drawing the gridlines and the bars like I did for the dots
function drawProblemBars(){    
d3.csv("problems2.csv", function(data){
		problemsDataset = data.map(function(d){return d;});
	
		//Nest by Unit
		var groups = d3.nest()
			 .key(function(d) { return d.Unit; })
			 .key(function(d) { return d.Type; })
			 .entries(data);
	
		//Select all rows of current unit
		d3.selectAll(groups)
			.each(function(d2, k){ 
				if(this.key == CURRENT_UNIT){
					//Map A and B separately for 4 groups of bars: A-correct, A-incorrect, B-correct, B-incorrect 
					d3.selectAll(this.values)
						.each(function(dat, j){

							//simplify selection for pre/post
							var corr = CURRENT_PREPOST + " Correct";
							var incorr = CURRENT_PREPOST + " Incorrect";

							var correctBars = barsholder.select(".correctBars" + this.key)
									.selectAll("rect")
										.data(this.values);												
							correctBars.enter()
									.append("rect");
							correctBars
									  .attr("class", function(d) { return d.Type + " correctbar";})
									  .attr("x", function(d, i) { return (j*barWidth)+i*((graphWidth/4)); })
									  .attr("width", barWidth)
									  .attr("y", function(d){ return barsY(+d[corr]/(+d[corr]+(+d[incorr])));})
									  .attr("height", function(d) {return problemSelectorHeight - barsY(+d[corr]/(+d[corr]+(+d[incorr]))); });	
							correctBars.exit()
									.remove();

							var incorrectBars = barsholder.select(".incorrectBars" + this.key)
									.selectAll("rect")
										.data(this.values);			
							incorrectBars.enter()
									.append("rect")
									  .attr("width", barWidth)
									  .attr("y", 0)
							incorrectBars
								.attr("class", function(d) { return d.Type + " incorrectbar";})
								.attr("x", function(d, i) { return (j*barWidth)+i*((graphWidth/4)); })
								.attr("height", function(d) { return problemSelectorHeight - barsY(+d[incorr]/(+d[corr]+(+d[incorr]))); });
							incorrectBars.exit()
									.remove();		
					   });
				}					
			});		
	
	
	});
}
drawProblemBars();

		
/******************************
Buttons
******************************/	
var buttons = [];
var buttonNames = ["Unit 2 Pre", "Unit 2 Post", "Unit 4 Pre", "Unit 4 Post"];

//Function that switches Unit Pre Post
function switchCondition(e){
	var pr = CURRENT_PREPOST;
	var un = CURRENT_UNIT
	
	switch(e.name){
		case buttonNames[0]:
			CURRENT_PREPOST = "Pre"
			CURRENT_UNIT = "2";
		break;
		case buttonNames[1]:
			CURRENT_PREPOST = "Post"
			CURRENT_UNIT = "2";
		break;
		case buttonNames[2]:
			CURRENT_PREPOST = "Pre"
			CURRENT_UNIT = "4";
		break;
		case buttonNames[3]:
			CURRENT_PREPOST = "Post"
			CURRENT_UNIT = "4";
		break;
	}
	if(CURRENT_PREPOST != pr || CURRENT_UNIT != un){
		console.log(CURRENT_PREPOST + " " + CURRENT_UNIT);
		drawDots();
		drawProblemBars();
	}
}
//Buttons to switch between Unit, Pre-Post (4 conditions total)
for(var x = 0; x < buttonNames.length; x++){

		var dy = x <= 1 ? 0 : 1;
		var temp  = svg.append("g")
		.attr("transform", "translate(" + 100*(x%2) + "," + buttonHeight*dy + ")");

		var n = buttonNames[x];
		temp.append("rect")
			.data([{name: n}])
			.attr("class", "switch")
			.attr("width", buttonWidth)
			.attr("height", buttonHeight)
			.on("click", function(e){switchCondition(e);});
		
		temp.append("text")
			.attr("class", "buttonText")
			.attr("transform", "translate(" + buttonWidth/5 + "," + buttonHeight/1.5 + ")")
			.text(buttonNames[x]);

		buttons[n] = temp;
}

</script>
</body>
</html>
