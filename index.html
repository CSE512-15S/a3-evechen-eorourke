<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>What Affects Learning Gains?</title>
		<style>

		.A.dot{
			fill: #FFA500;
		}
		
		.B.dot{
			fill: #4169E1;
		}
		
		.unknown.dot{
			opacity: 0.0;
		}
		
		.bar{
			stroke-width: 2;
		}
        
        .hitArea{
            fill:none;
            pointer-events: all;
        }

        .hitArea:hover + rect{
            stroke: black;
        }
        
		rect.bar:hover{
			stroke: black;
		}

		.A.correct.selected{
			fill: #FFA500;
			stroke: #FFA500;
		}
		
		.B.correct.selected{
			fill: #4169E1;
			stroke: #4169E1;
		}
		
		.A.incorrect.selected{
			fill: #DFCBA6;
			stroke: #DFCBA6;
		}
		
		.B.incorrect.selected{
			fill: #D5D8E4;
			stroke: #D5D8E4;
		}
		
		.A.correct.unselected{
			fill: #DDDDDD;
			stroke: #999999;
			stroke-width: 1;
		}
		
		.B.correct.unselected{
			fill: #DDDDDD;
			stroke: #999999;
			stroke-width: 1;
		}
		
		.A.incorrect.unselected{
			fill: #DDDDDD;
			stroke: #999999;
			stroke-width: 1;
		}
		
		.B.incorrect.unselected{
			fill: #DDDDDD;
			stroke: #999999;
			stroke-width: 1;
		}
				
		.switch.unpressed{
			fill: #D3D3D3;
			stroke: #D3D3D3;
			stroke-width: 2;
		}
		
		.switch.pressed{
			fill: #A8A8A8;
			stroke: #494949;
			stroke-width: 2;
		}

		
		.switch.unpressed:hover{
			fill: #808080;
			stroke: #808080;
		}
		
		.buttonText{
			pointer-events:none;
			font-size: 10pt;
            font-family: Verdana;
		}
		
		.buttonHolder{
			fill: #000000:
		}
		.axis {
            font-size: 10pt;
            font-family: Verdana;
            color: #CCCCCC;
            fill-opacity: .6;			
        }

		.axis path,
		.axis line {
			stroke: #CCCCCC;
			fill: none;
			stroke-width: 1px;
		}
		
		.axis path.domain{
			stroke-width: 0px;
		}
		
		.zero.axis{
			stroke-dasharray: 1,2;
			stroke-width: 1px;
			stroke: #808080;
		}
		.tick {
			font-size: 8pt;
		}
		
		svg{
		}
		</style>
		<script src="d3.min.js"></script>
	</head>
<body>
<script>
/******************************************
 * Layout and appearance variables 
 ******************************************/
var graphHeight = 200, 
	graphWidth = 200;
var problemSelectorHeight = 100;
var margin = {top: 50, right: 50, bottom: 50, left: 50};
var width = (10*graphWidth) + (8*margin.left), 
	height = (2*graphHeight) + (3*margin.top) + 2*problemSelectorHeight;

var defaultRange = [0, graphWidth]; //for visual mapping, so should be same for all graphs?

var barWidth = 10;
var barSpacing = (barWidth*2) + 20;
var barMargin = {top: 10, right: 10, bottom: 10, left: 10};
var barStrokeWidth = 2;
var barHitVert = 10; //extra hit area padding for top or bottom
var barHitHor = 10; //extra hit area padding for left or right
var allBarsSelected = true;

var buttonHeight = 20, 
	buttonWidth = 100;
	
/******************************************
 * Global(?) functions/variables - maybe put into their individual callbacks to prevent accidentally overwriting axes/scale info
 ******************************************/
 	//Holds data from CSV files
 	var conditions = [];
	var graphParams = [];
    var studentDataset = [];
    var problemsDataset = [];
    
    //Default starting variables
    var CURRENT_UNIT = "2";
    var CURRENT_PREPOST= "Pre"; 
    var CURRENT_BUTTON = null;
    
    //the main SVG
    var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)

	//y axis - should be the same for all graphs
	function addYAxis(elem, offset){
		elem.append("g")
		  .attr("class", "y axis")
		  .call(yAxis)
		.append("text")
		  .attr("transform", "rotate(-90)")
		  .attr("y", 0 - margin.left)
		  .attr("x",0 - (graphHeight / 2))
		  .attr("dy", "1.5em")
		  .style("text-anchor", "middle")
		  .text("Learning Gains");
    }
    
	var yScale = d3.scale.linear()
		.domain([-20, 20]) //default, is changed in callback
		.range([200, 0]);

	var yAxis = d3.svg.axis()
		.scale(yScale)
		.orient("left")
		.ticks(10, "")


/******************************
 * Map student data to graphs
 ******************************/	
function drawDots(){
	//Alter the range for Y axis
	var min = d3.min(studentDataset, function(d) { return +d["Unit " + CURRENT_UNIT + " Learning Gain"];})
	var max = d3.max(studentDataset, function(d) { return +d["Unit " + CURRENT_UNIT + " Learning Gain"];})
	var yDottedOffset = Math.abs(max - min) * 0.1;
	yScale.domain([min-yDottedOffset, max]); //TODO make min like 10% less than actual min or something
	
	d3.selectAll(graphParams)
		.each(function(d, i) {
			//Current Graph Holder
			var holder = svg.select(".graph" + i + ".graphHolder");
			holder.selectAll(".axis").remove();
			
			//X Scale and Axis
			//TODO nonstatic offset for domain, based on actual data domain, maybe 10%?
			min = d3.min(studentDataset, function(d) { return +d[graphParams[i]];})
			max = d3.max(studentDataset, function(d) { return +d[graphParams[i]];})
		    var xDottedOffset = Math.abs(max - min) * 0.1;
			
			var x = d3.scale.linear()
					.domain([min-xDottedOffset, max])
					.range(defaultRange);
							
			//X Axis
			var xAxis = d3.svg.axis()
					.scale(x)
					.orient("bottom")
					.ticks(5, "");
			
			holder.append("g")
					.attr("class", "x axis")
					.attr("transform", "translate(0," + graphHeight + ")")
					.call(xAxis)
				  .append("text")
					  .attr("transform", "translate(" + (graphWidth / 2) + " ," + (margin.bottom-15) + ")")
					  .style("text-anchor", "middle")
					  .text(graphParams[i]);
			
			//Y Axis
			addYAxis(holder, yDottedOffset);
					
			//Dotted lines intersecting at 0
			//Vertical Line
			holder.append("line")
					.attr("class", graphParams[i] + " zero axis")
					.attr("x1", x(0))
					.attr("y1", 0)
					.attr("x2", x(0))
					.attr("y2", graphHeight)
			
			//Horizontal Line
			holder.append("line")
					.attr("class", graphParams[i] + " zero axis")
					.attr("x1", 0)
					.attr("y1", yScale(0))
					.attr("x2", graphWidth)
					.attr("y2", yScale(0));
										
			//Redraw/Draw dots					
			var dots = holder.selectAll("circle")
				.data(studentDataset);
													
			dots.enter().append("circle")
				.attr("cy", 0)
				.attr("cx", 0)
				.attr("r", 1.5);
			
			dots.attr("class", function(d) {
						var t = d["Unit " + CURRENT_UNIT + " Pre-Test Type"].toUpperCase();
						if(CURRENT_PREPOST == "Post"){
							if(t == "A")
								t == "B";
							else if(t == "B")
								t == "A";
							else
								t == "unknown";
						}
						if(t == "A" || t == "B")
							return t + " dot";
						else
							return "unknown dot";
					})
				.attr("transform", function(d) { 
							var gains = d["Unit " + CURRENT_UNIT + " Learning Gain"];
							var cat = +d[graphParams[i]];
			
							if(isNaN(gains) || isNaN(cat))
								return "translate(0,0)";
							else
								return "translate(" + x(cat) + "," + yScale(+gains) + ")";
						})
				.attr("opacity", function(d){ return isNaN(d["Unit " + CURRENT_UNIT + " Learning Gain"]) ? 0 : 1;})
			
			dots.exit()
				.remove();
	});
}

// version that does not nest by condition
function drawGraphs() {
	d3.csv("students2.csv", function(data){
		
		//Assign loaded data to variables
		studentDataset = data.map(function(d){return d;});
		graphParams = d3.keys(data[0]).slice(14, 20); //only select the 6 parameters we want to make graphs for

		d3.selectAll(graphParams)
			.each(function(d, i) {		
				// Create the graph container
				var colNum = i;
				var rowNum = 0;
				if (i > 2) {
					colNum = i - 3;
					rowNum = 1;
				}
				
				var holderX = margin.left + colNum*(graphWidth+2*margin.left);
				var holderY = margin.top - 30 + rowNum*(graphHeight+margin.top+20);
				var holder = svg.append("g")
					.attr("class", " graph" + i + " graphHolder")
					.attr("width", graphWidth)
					.attr("height", graphHeight)
					.attr("transform", "translate(" + holderX + "," + holderY + ")");
			});
		
		drawDots();
	});
}

//initial loading
drawGraphs();

/********************************
Map problem correctness data to bottom bar
********************************/
//Container
var barsholderX = margin.left;
var barsholderY = (2*graphHeight) + (3*margin.top);
var barsholder = svg.append("g")
	.attr("class", "barsHolder")
	.attr("width", width)
	.attr("height", problemSelectorHeight)
	.attr("transform", "translate(" + barsholderX + "," + barsholderY + ")");
	
   //TODO alter the range based on actual learning gains range?
var barsY = d3.scale.linear()
	.domain([0, 1])
	.range([100+barStrokeWidth, 0]); 

var barsYAxis = d3.svg.axis()
	.scale(barsY)
	.orient("left")
	.ticks(2, "%");	
	
//Y Axis, percentage
barsholder.append("g")
	  .attr("class", "axis")
	  .call(barsYAxis)
	.append("text")
	  .attr("transform", "rotate(-90)")
	  .attr("y", 0 - margin.left)
	  .attr("x",0 - (problemSelectorHeight / 2))
	  .attr("dy", "0.8em")
	  .style("text-anchor", "middle")
	  .text("% Correct");
	  
//TODO clean this part up a bit? forloop + array for class names, maybe
//Holders for correct bars
barsholder.append("g")
   .attr("class", "correctBarsA oneBarTypeHolder")
   .attr("width", width)
   .attr("height", problemSelectorHeight)

barsholder.append("g")
   .attr("class", "correctBarsB oneBarTypeHolder")
   .attr("width", width)
   .attr("height", problemSelectorHeight)
   
//Holders for incorrect bars
barsholder.append("g")
   .attr("class", "incorrectBarsA oneBarTypeHolder")
   .attr("width", width)
   .attr("height", problemSelectorHeight)

barsholder.append("g")
   .attr("class", "incorrectBarsB oneBarTypeHolder")
   .attr("width", width)
   .attr("height", problemSelectorHeight)

// Add the "Select All" and "Deselect All" buttons
var selectAllButton = svg.append("g")
	.attr("class", "buttonHolder")
	.attr("transform", "translate(" + 1250 + "," + barsholderY + ")");
selectAllButton.append("rect")
	.attr("class", "switch unpressed")
	.attr("width", buttonWidth)
	.attr("height", buttonHeight)
	.on("click", function(){selectAll();});
selectAllButton.append("text")
	.attr("class", "buttonText")
	.attr("transform", "translate(" + buttonWidth/5 + "," + buttonHeight/1.5 + ")")
	.text("Select All");

var deselectAllButton = svg.append("g")
	.attr("class", "buttonHolder")
	.attr("transform", "translate(" + 1250 + "," + (barsholderY + 1.5*buttonHeight) + ")");
deselectAllButton.append("rect")
	.attr("class", "switch unpressed")
	.attr("width", buttonWidth)
	.attr("height", buttonHeight)
	.on("click", function(){deselectAll();});
deselectAllButton.append("text")
	.attr("class", "buttonText")
	.attr("transform", "translate(" + ((buttonWidth/5)-10) + "," + buttonHeight/1.5 + ")")
	.text("Deselect All");


function selectAll() {
	allBarsSelected = true;
	d3.selectAll(".bar")
		.each(function(){
			var bar_class = this.getAttribute("class");
			var endIndex = bar_class.indexOf("bar") + 4; 
			var new_class = bar_class.substring(0,endIndex) + "selected";
			this.setAttribute("class", new_class);
		});
}

function deselectAll() {
	d3.selectAll(".bar")
		.each(function(){
			var bar_class = this.getAttribute("class");
			var endIndex = bar_class.indexOf("bar") + 4; 
			var new_class = bar_class.substring(0,endIndex) + "unselected";
			this.setAttribute("class", new_class);
		});
}

function onBarClick(bar_object, d) {
	if (allBarsSelected) {
		deselectAll();
		allBarsSelected = false;
	}
	
	var bar_class = bar_object.getAttribute("class");
	var new_class = bar_class.replace(/unselected/g, 'selected');
	bar_object.setAttribute("class", new_class);
	
	// d3.select(bar_object).style("stroke", "magenta");
	// var bar_class = d3.select(bar_object).attr("class");
	// console.log("bar_class: " + bar_class);
	// var new_class = bar_class.replace(/unselected/g, 'selected');
	// d3.select(bar_object).attr("class", new_class);
	// var bar_class = d3.select(bar_object).attr("class");
	// console.log("bar_class: " + bar_class);
	
	// console.log("bar clicked! unit: " + d["Unit"]);
	// console.log("bar clicked! type: " + d["Type"]);
	// console.log("bar clicked! question: " + d["Question"]);
	// 
	// var type = d["Type"];
	// var question = d["Question"];
	// 
	// var identifier = "rect#" + question + "." + bar_class;
	// var iden = "." + bar_class + ", rect"
	// var bars = d3.selectAll("rect." + bar_class);
	// 
	// 
	// var idString = "#problem" + d["Question"];
	// idString = idString.replace(/\./g,"");
	// console.log("idString: " + idString);
	// 
	// var b = d3.selectAll(idString).selectAll("."+bar_class).style("fill", "black");
	// //.selectAll("."+bar_class);
	// 
	// console.log("class: " + bar_class);
	// console.log("bars: " + bars);
	// console.log("b: " + b);
}

	   
//TODO separate out drawing the gridlines and the bars like I did for the dots
function drawProblemBars(){    
d3.csv("problems2.csv", function(data){
	problemsDataset = data.map(function(d){return d;});
	
	// When you select a new unit and test, we want all the bars to start out selected
	allBarsSelected = true;

	//TODO create a wrapper for each bar that is its mouseover area
	//.data([{selected: false}]) to store info about whether it is pressed or not
	//add interactivity to bars 

	//Nest by Unit
	var groups = d3.nest()
		 .key(function(d) { return d.Unit; })
		 .key(function(d) { return d.Type; })
		 .entries(data);
	
	//Select all rows of current unit
	d3.selectAll(groups)
		.each(function(d2, k){ 
			if(this.key == CURRENT_UNIT){
				//Map A and B separately for 4 groups of bars: A-correct, A-incorrect, B-correct, B-incorrect 
				d3.selectAll(this.values)
					.each(function(dat, j){

						//simplify selection for pre/post
						var corr = CURRENT_PREPOST + " Correct";
						var incorr = CURRENT_PREPOST + " Incorrect";

						var correctBars = barsholder.select(".correctBars" + this.key)
								.selectAll("rect")
								.data(this.values);																
						correctBars.enter().append("rect");
						
						//must draw hitArea before actual bar for CSS next sibling selector to work            
						// correctBars
						// 	.append("rect")
						// 	.data(this.values)
						// 		.attr("class", " hitArea")
						// 		.attr("x", function(d, i) { return (-1*barHitHor + j*barHitHor) + (j*(barStrokeWidth + barWidth))+i*(barSpacing); })
						// 		.attr("y", function(d){ return barsY(+d[corr]/(+d[corr]+(+d[incorr])));})
						// 		.attr("width", barWidth + barHitHor)
						// 		.attr("height", function(d) {return barHitVert + barStrokeWidth + problemSelectorHeight - barsY(+d[corr]/(+d[corr]+(+d[incorr]))); });                                     
						
						correctBars
							.attr("class", this.key + " correct bar selected")
							.attr("x", function(d, i) { return (j*(barStrokeWidth + barWidth))+i*(barSpacing); })
							.attr("width", barWidth)
							.attr("y", function(d){ return barsY(+d[corr]/(+d[corr]+(+d[incorr])));})
							.attr("height", function(d) {return barStrokeWidth + problemSelectorHeight - barsY(+d[corr]/(+d[corr]+(+d[incorr]))); })
							.on("click", function(d){onBarClick(this, d);});
							
						correctBars.exit().remove();

						var incorrectBars = barsholder.select(".incorrectBars" + this.key)
								.selectAll("rect")
								.data(this.values);			
						incorrectBars.enter().append("rect")
						
						//must draw hitArea before actual bar for CSS next sibling selector to work            
						// incorrectBars
						// 	.append("rect")
						// 	.data(this.values)
						// 		.attr("class", " hitArea")
						// 		.attr("x", function(d, i) { return (-1*barHitHor + j*barHitHor) + (j*(barStrokeWidth + barWidth))+i*(barSpacing); })
						// 		.attr("y", -1*barHitVert)
						// 		.attr("width", barWidth + barHitHor)
						// 		.attr("height", function(d) {return barHitVert + Math.max(0, problemSelectorHeight - barsY(+d[incorr]/(+d[corr]+(+d[incorr])))); });                                     
						
						incorrectBars
							.attr("class", this.key + " incorrect bar selected")
							.attr("x", function(d, i) { return (j*(barStrokeWidth + barWidth))+i*(barSpacing); })
							.attr("width", barWidth)
							.attr("y", 0)
							.attr("height", function(d) { return Math.max(0, problemSelectorHeight - barsY(+d[incorr]/(+d[corr]+(+d[incorr])))); })
							.on("click", function(d){onBarClick(this, d);});
							
						incorrectBars.exit().remove();		
				   });
			}
		});		
});
}
drawProblemBars();

		
/******************************
Buttons
******************************/	
var buttons = [];
var buttonNames = ["Unit 2 Pre", "Unit 2 Post", "Unit 4 Pre", "Unit 4 Post"];
var shrinkConstant = 0.98;

//Change size of an unpressed button
function setUnpressedSize(){
	this.attr("class", "switch unpressed");
}

//Change size of a pressed button
function setPressedSize(){
	this.attr("class", "switch pressed");	
}
//Function that switches Unit Pre Post
function switchCondition(e){
	var pr = CURRENT_PREPOST;
	var un = CURRENT_UNIT
	
	switch(e.name){
		case buttonNames[0]:
			CURRENT_PREPOST = "Pre"
			CURRENT_UNIT = "2";
		break;
		case buttonNames[1]:
			CURRENT_PREPOST = "Post"
			CURRENT_UNIT = "2";
		break;
		case buttonNames[2]:
			CURRENT_PREPOST = "Pre"
			CURRENT_UNIT = "4";
		break;
		case buttonNames[3]:
			CURRENT_PREPOST = "Post"
			CURRENT_UNIT = "4";
		break;
	}
	if(CURRENT_PREPOST != pr || CURRENT_UNIT != un){
		for(var x = 0; x < buttonNames.length; x++){
			if (buttonNames[x] != e.name){
				buttons[buttonNames[x]].select("rect").call(setUnpressedSize);
			}
			else{
				buttons[buttonNames[x]].select("rect").call(setPressedSize);
			}
		}
		drawDots();
		drawProblemBars();
	}
}
//Make buttons to switch between Unit, Pre-Post (4 conditions total)
for(var x = 0; x < buttonNames.length; x++){

		var dy = x <= 1 ? 0 : 1;
		var temp  = svg.append("g")
		.attr("class", "buttonHolder")
		.attr("transform", "translate(" + (900+110*(x%2)) + "," + 1.5*buttonHeight*dy + ")");

		var n = buttonNames[x];
		temp.append("rect")
			.data([{name: n}])
			.attr("class", "switch unpressed")
			.attr("width", buttonWidth)
			.attr("height", buttonHeight)
			.on("click", function(e){switchCondition(e);});
		
		temp.append("text")
			.attr("class", "buttonText")
			.attr("transform", "translate(" + buttonWidth/5 + "," + buttonHeight/1.5 + ")")
			.text(buttonNames[x]);

		buttons[n] = temp;
}

buttons[buttonNames[0]].select("rect").attr("class", "switch pressed");

</script>
</body>
</html>
